# This is a draft!

# Introduction

A [recent paper](https://arxiv.org/abs/1311.3903) suggested a new mathematical
point of view on version control. I first found out about it from `pijul`, a
new version control system (VCS) based around those ideas. But if you poke
around the `pijul` [home page](https://pijul.com/), you won't find many details
about what makes it different from existing VCSes. So I did a bit of digging,
and this series of blog posts is the result.

In the first part (i.e. this one), I'll go over some of the theory developed in
the paper. In particular, I'll describe a way to think about patches and
merging that is guaranteed to never, ever have a merge conflict. In the second
part, I'll show how `pijul` puts that theory into action, and in the third part
I'll dig into `pijul`'s implementation.

# Patches

A patch is the difference between two files. Later in this series we'll be
looking at some wild new ideas, so let's start with something familiar and
comforting. The kind of patches we'll discuss here are essentially unchanged
since the early days of Unix:

- a patch works line-by-line (as opposed to, for example, word-by-word); and
- a patch can delete lines and add new lines, but not modify existing lines.

For an example, let's start with a simple file: my to-do list for this morning.

![](merge_tikz_block_1.svg)

Looking back at the list, I realize that I forgot something important. Here's the new one:

![](merge_tikz_block_2.svg)

To go from the original to-do list to the new one, I added the line with the
socks. In the format of the original Unix "diff" utility, the patch would look like this:

![](merge_tikz_block_3.svg)

The "1a2" line is a code saying that we're going to add something after line 1 of the
input file, and the next bit is obviously telling us what to insert.

Since this blog isn't a command line tool, we'll represent patches with pretty diagrams
instead of flat files. Here's how we'll draw the patch above:

![](merge_tikz_block_4.svg)

Hopefully it's self-explanatory, but just in case: lines that are on the right
with no arrow coming out are the ones that got deleted. Lines on the left with
no arrow coming in are the ones that got added. Otherwise, an arrow points from
the original position of a line to its new position. Since patches aren't
allowed to re-order the lines, they're guaranteed to always be non-crossing.

There's something implicit in our notation that really needs to be said out
loud: for us, a patch is tied to a specific input file. This is the first point
where we diverge from the classic Unix ways: the classic Unix patch that we
produced using "diff" could in principle be applied to *any* input file, and it
would still insert "* put on socks" after the first line. In many cases that
wouldn't be what you want, but sometimes it is.

# Merging

The best thing about patches is that they can enable multiple people to edit
the same file and then merge their changes afterwards. Let's suppose that my
wife also decides to put things on my to-do list: she
takes the original file and adds a line:

![](merge_tikz_block_5.svg)

Now there are two new versions of my to-do list: mine with the socks, and my
wife's with the garbage. Let's draw them all together:

![](merge_tikz_block_6.svg)

This brings us to merging: since I'd prefer to have my to-do list as a single
file, I want to merge my wife's changes and my own. In this example, it's
pretty obvious what the result should be, but let's look at the general problem
of merging. We'll do this slowly and carefully, and our endpoint might be
different from what you're used to (unless you're a `darcs` fan).

## Patch composition

First, I need to introduce some notation for an obvious concept: the
*composition* of two patches is the patch that you would get by applying one
patch and then applying the other. Since a "patch" for us also includes the
original file, you can't just compose any two old patches. If `p` is a patch
taking the file `O` to the file `A` and `r` is a patch taking `A` to `B`, then
you can compose the two (but only in one order!) to obtain a patch from `O` to
`B`. I'll write this composition as `pr`: first apply `p`, then `r`.

It's pretty easy to visualize patch composition using our diagrams: to compute
the composition of two paths, just "follow the arrows"

![](merge_tikz_block_7.svg)

to get the (dotted red) patch going from `O` to `B`.

## Merging as composition

Let's define carefully what a merge is: if `p` and `q` are two different patches
taking the file `O` to the files `A` and `B` respectively, a *merge* of `p` and `q`
is a pair of patches `r` and `s` such that

* `r` and `s` take `A` and `B` respectively to a common output file `M`, and
* `pr = qs`.

We can illustrate this definition with a simple diagram, where the capital
letters denote files, and the lower-case letters are patches going between
them:

![](merge_tikz_block_8.svg)

Instead of saying that `pr = qs`, a mathematician (or, at least, one who likes
to sound fancy) would say that the diagram above *commutes*.

Here is an example of a merge:

![](merge_tikz_block_9.svg)

And here is an example of something that is not a merge:

![](merge_tikz_block_10.svg)

This is not a merge because it fails the condition `pr = qs`: composing the
patches along the top path gives

![](merge_tikz_block_11.svg)

but composing them along the bottom path gives

![](merge_tikz_block_12.svg)

Specifically, the two patches disagree on whether the chocolate in the merged
list came from the original file. This is the real meaning underlying
the condition `pr = qs`: it means that there will never be any ambiguity
about whether or not a line was introduced between two revisions.
If you're used to using `blame` or `annotate` commands with your favorite VCS,
you can probably imagine why this sort of ambiguity would be bad.

## A historical note

Merging patches is an old idea, of course, and so I just want to briefly
explain how the presentation above differs from "traditional" merging:
traditionally, merging was defined by algorithms (of which there are
[many][1]). These algorithms would try to automatically find a good merge; if
they couldn't, you would be asked to supply one instead.

[1]: https://en.wikipedia.org/wiki/Merge_(version_control)#Merge_algorithms

We'll take a different approach: instead of starting with an algorithm, we'll
start with a list of properties that we want a good merge to satisfy. At the end,
we'll find that there's a unique merge that satisfies all these properties
(and fortunately for us, there will also be an efficient algorithm to find it).

# Merges aren't unique

## A silly example

The main problem with merges are that they aren't unique: let's start with a silly
example:

![](merge_tikz_block_13.svg)

No merge tool would ever do that, of course, but it's still a valid
merge according to our rule in the last section. Clearly, we'll have
to tighten up the rules.

## A serious example

Here is a more difficult situation with more than one possible merge:

![](merge_tikz_block_14.svg)

Both of these merges are valid according to our rules above, but you need to
actually know what the lines *mean* in order to decide that the first merge is
better (especially if it's raining outside). Any reasonable automatic merging
tool would refuse to choose, instead requiring its user to do the merge
manually.

The examples above are pretty simple, but how would you decide in general
whether a merge is unambiguous and can be performed automatically? In existing
tools, the details depend on the merging algorithm. Since we started off with
a non-algorithmic approach, let's see where that leads: instead of specifying
explicitly which merges we can do, we'll describe the properties that an ideal
merge should have.

# Perfect merges

Finally, I'm ready to define the ideal merge. The main idea behind the
definition I'm about to give is that it will never cause any regrets. That is,
no matter what happens in the future, we can always represent the history just
as well through the merge as we could using the original branches. Obviously,
that's a nice property to have; personally, I think it's non-obvious why it's
a good choice as the *defining* property of the ideal merge, but we'll get to
that later.

Ok, here it comes. Consider a merge:

![](merge_tikz_block_15.svg)

And now suppose that the original creators of patches `p` and `q`
continued working on their own personal branches, which merged sometime in
the future at the file `F`:

![](merge_tikz_block_16.svg)

We say that the merge `(r, s)` is a *perfect merge* if for *every* possible
choice of the merge `(u, v)`, there is a unique patch `w` so that `u = rw`
and `v = sw`. (In math terms, the diagram commutes.)
We're going to call `w` a *continuation*, since it tells us how to continue
working from the merged file.


## A perfect merge

Let's do a few examples to explore the various corners of our definition.
First, an example of a perfect merge:

![](merge_tikz_block_17.svg)


It takes a bit of effort to actually *prove* that this is a perfect merge;
I'll leave that as an exercise. It's more interesting to see some examples
that fail to be perfect.

## A silly example

Let's start with the silly example of a merge that introduced an unnecessary
line:

![](merge_tikz_block_18.svg)

This turns out (surprise, surprise) not to be a perfect merge; the reason is
that our definition of perfection required that there is always a *unique* continuation.

But here is an example of a possible future without a unique continuation:

![](merge_tikz_block_19.svg)

(That's right: the patches leading to `future` are exactly the same as the
patches leading to `merged`.) Now there are two possible patches between
`merged` and `future` that will both result in a commuting diagram:

![](merge_tikz_block_20.svg)

and

![](merge_tikz_block_21.svg)

## A serious example

Here's another example, the case where there is an ambiguity in the order
of two lines in the merged file:

![](merge_tikz_block_22.svg)

This one fails to be a perfect merge because there is a future with
no valid continuation: imagine that my wife and I manually created the desired merge.

![](merge_tikz_block_23.svg)

Now what patch (call it `w`) could be put between `merged` and `future` to make
everything commute? Well, from the patch between `mine` and `future`,
you see that the shoes are preserved; that means that `w` has to keep the shoes line.
Looking at the patch between `wife's` and `future`, the same logic implies that
`w` has to keep the garbage line. Then the only possibility for `w` is

![](merge_tikz_block_24.svg)

which isn't a legal patch because patches aren't allowed to swap lines. To
summarize, the merge we were considering isn't perfect because we gave an
example of a future which had no continuation.

## Terminological remarks

If you've been casually reading about pijul, you might have encountered the
word "pushout." It turns out that the pattern we used for defining a perfect
merge is very common in math. Specifically, in category theory, suppose you
have the following diagram (in which capital letters are objects
and lowercase letters are morphisms):

![](merge_tikz_block_25.svg)

If for every `u` and `v` there is a unique `w` such that the diagram commutes,
then `(r, s)` is said to be the *pushout* of `(p, q)`. In other words, what we
called a "perfect merge" above could also be called a pushout in the category
with files as objects and patches as morphisms.
For most of this article, we'll ignore the general math terminology in favor
of language that's more intuitive and specific to files and patches.


# Conflicts and dagles

The main problem with perfect merges is that they don't always exist. In fact,
we already saw an example:

![](merge_tikz_block_26.svg)

The pair of patches above has no perfect merge. We haven't actually proved it,
but intuitively it's pretty clear, and we also discussed earlier why one
potential merge fails to be perfect. Ok, so not every pair of patches can be
merged perfectly. You probably knew that already, since that's where merge
conflicts come from: the VCS doesn't know how to merge patches on its own, so
you need to manually resolve some conflicts.

Now we come to the coolest part of the paper: a totally different idea for
dealing with merge conflicts. The critical part is that instead of making do
with an imperfect merge, we enlarge the set of objects that the merge can
produce. That is, not every pair of patches can be perfectly merged to
a *file*, but maybe they can be merged to something else.
This idea is extremely common in math, and there's even some general abstract
nonsense showing that it can always be done: there's an abstract way to
generalize files so that every pair of patches of generalized files can be
perfectly merged. The miraculous part here is that in this particular case,
the abstract nonsense condenses into something completely explicit and manageable.

## Dagles

A file is an ordered list of lines. A *dagle* (for **d**irected **a**cyclic
**g**raph fi**le**) is a directed acyclic graph of lines. (Yes, I know it's
a terrible name, but it's better than "object in the free finite cocompletion
of the category of files and patches," which is what the paper calls it.)
In other words, whereas a file insists on having its lines in a strict order,
a dagle allows lines to be partially ordered. It's pretty easy to see how relaxing
the strict ordering of lines solves our earlier merging issues.
For example, here's a perfect merge of the sort that caused us problems before:

![](merge_tikz_block_27.svg)

In retrospect, this is a pretty obvious solution: if we don't know what order
shoes and garbage should go in, we should just produce an output that doesn't
specify the order. What's a bit less obvious (but is proved in the paper)
is that when we work in the world of dagles instead of the world of files,
*every* pair of patches has a unique perfect merge. What's even cooler is
that the perfect merge is easy to compute. I'll describe it in a second,
but first I have to say how patches generalize to dagles.

A patch between two dagles (say, `A` and `B`) is a partial function
(call it `p`) from the lines of `A` to the lines of `B` that respects
the partial order, in the sense that if `x < y` in `A` then `p(x) < p(y)` in `B`.
Here's an example:

![](merge_tikz_block_28.svg)

And now for the merge algorithm: let's say we have a patch `p` going from the
dagle `A` to the dagle `B` and another patch `q` going from `A` to `C`. To
compute the perfect merge of `p` and `q`,

1. write down the dagles `B` and `C` next to each other, and then
2. whenever a line in `B` and a line in `C` share a "parent" in `A`, collapse them into a single line.

That's it: two steps. Here's the algorithm at work on our previous example: we
want to merge these two patches:

![](merge_tikz_block_29.svg)

So first, we write down the two to-be-merged files next to each other:

![](merge_tikz_block_30.svg)

For the second step, we see that both of the "to-do" lines came from the same
line in the original file, so we combine those two into one. After doing the
same to the "work" lines, we get the desired output:

![](merge_tikz_block_31.svg)

## But how do I work with a dagle?

By generalizing files to dagles, we got a very nice benefit: every pair of
patches has a (unique) perfect merge, and we can compute it easily. But
there's an obvious flaw: all the tools that we use (editors, compilers, etc.)
work on files, not dagles. This is where the
[paper](https://arxiv.org/abs/1311.3903) leaves us, but there is an easy solution:
whenever a merge results in something that isn't a file, the VCS just
asks you to supply a new patch that results in a file. We'll call it a *filification*,
and here's an example:

![](merge_tikz_block_32.svg)

Since the VCS will request a filification whenever a merge results in a dagle,
your editor and compiler will only ever see files!

## But how is that new?

If your eyes haven't glazed over by now, you might be feeling a bit cheated:
I promised you a new framework that avoids the pitfalls of manual merge
resolution, but filification looks an awful lot like manual merge resolution.
I'll answer this criticism in more detail in the next post, where I demonstrate
the `pijul` tool and how it differs from `git`. But here's a little teaser: the
difference between filification and manual merge resolution is that
filification is completely transparent to the VCS: it's just a patch like any
other. That means we can do fun things, like re-ordering or reverting patches,
even in the presence of conflicting merges.
But more on that in the next post.
